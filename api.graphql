schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}
type Query {
  botUser(where: BotUserWhereUniqueInput!): BotUser
  botUsers(where: BotUserWhereInput, orderBy: BotUserOrderByInput, first: Int!, last: Int!, before: BotUserWhereUniqueInput, after: BotUserWhereUniqueInput): [BotUser!]!
  clientSecret(where: ClientSecretWhereUniqueInput!): ClientSecret
  clientSecrets(where: ClientSecretWhereInput, orderBy: ClientSecretOrderByInput, first: Int!, last: Int!, before: ClientSecretWhereUniqueInput, after: ClientSecretWhereUniqueInput): [ClientSecret!]!
  subscribeToken(where: SubscribeTokenWhereUniqueInput!): SubscribeToken
  subscribeTokens(where: SubscribeTokenWhereInput, orderBy: SubscribeTokenOrderByInput, first: Int!, last: Int!, before: SubscribeTokenWhereUniqueInput, after: SubscribeTokenWhereUniqueInput): [SubscribeToken!]!
  whoAmI: UserAccount!
  userAccount(where: UserAccountWhereUniqueInput!): UserAccount
  userAccounts(where: UserAccountWhereInput, orderBy: UserAccountOrderByInput, first: Int!, last: Int!, before: UserAccountWhereUniqueInput, after: UserAccountWhereUniqueInput): [UserAccount!]!
  hello: String!
  app(where: AppWhereUniqueInput!): App
  apps(where: AppWhereInput, orderBy: AppOrderByInput, first: Int!, last: Int!, before: AppWhereUniqueInput, after: AppWhereUniqueInput): [App!]!
  appSubscription(where: AppSubscriptionWhereUniqueInput!): AppSubscription
  appSubscriptions(where: AppSubscriptionWhereInput, orderBy: AppSubscriptionOrderByInput, first: Int!, last: Int!, before: AppSubscriptionWhereUniqueInput, after: AppSubscriptionWhereUniqueInput): [AppSubscription!]!
}
input BotUserWhereUniqueInput {
  id: Int
  botUser_botId: BotUserBotIdCompoundUniqueInput
}
input BotUserBotIdCompoundUniqueInput {
  botUser: String!
  botId: Int!
}
type BotUser {
  id: Int!
  name: String
  botUser: String!
  botId: Int!
  bot: Bot!
  userAccountId: Int!
  userAccount: UserAccount!
  createdAt: DateTime!
  updatedAt: DateTime!
  requiresUpdate: UpdateRequiredPayload!
}
type Bot {
  id: Int!
  type: BotType!
  botUsers(first: Int!, last: Int!, before: BotUserWhereUniqueInput, after: BotUserWhereUniqueInput): [BotUser!]!
  appSubscriptions(first: Int!, last: Int!, before: AppSubscriptionWhereUniqueInput, after: AppSubscriptionWhereUniqueInput): [AppSubscription!]!
}
enum BotType {
  SLACK
  TELEGRAM
}
input AppSubscriptionWhereUniqueInput {
  id: Int
  name_appId: NameAppIdCompoundUniqueInput
  appId_botId_channel: AppIdBotIdChannelCompoundUniqueInput
}
input NameAppIdCompoundUniqueInput {
  name: String!
  appId: Int!
}
input AppIdBotIdChannelCompoundUniqueInput {
  appId: Int!
  botId: Int!
  channel: String!
}
type AppSubscription {
  id: Int!
  name: String!
  description: String!
  muted: Boolean!
  mutedUntil: DateTime
  environment: Environment
  appId: Int!
  app: App!
  subscriberId: Int!
  subscriber: UserAccount!
  botId: Int!
  bot: Bot!
  channel: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}
"""A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar."""
scalar DateTime
enum Environment {
  DEVELOPMENT
  TEST
  PRODUCTION
}
type App {
  id: Int!
  name: String!
  ownerId: Int!
  owner: UserAccount!
  subscribeTokenCount: Int!
  subscribeTokens(where: SubscribeTokenWhereInput, orderBy: SubscribeTokenOrderByInput): [SubscribeToken!]!
  appSubscriptionCount: Int!
  appSubscriptions(where: AppSubscriptionWhereInput, orderBy: AppSubscriptionOrderByInput): [AppSubscription!]!
  clientSecrets(where: ClientSecretWhereInput, orderBy: ClientSecretOrderByInput): [ClientSecret!]!
  createdAt: DateTime!
  updatedAt: DateTime!
  logCount(where: AppLogWhereInput): Int!
  logs(first: Int!, after: AppLogWhereUniqueInput, where: AppLogWhereInput): [AppLog!]!
  metrics(where: AppMetricsWhereInput): AppMetrics!
  status(where: AppStatusWhereInput): AppStatus!
  statusHistory(first: Int!, after: AppStatusWhereUniqueInput, where: AppStatusWhereInput): [AppStatus!]!
}
type UserAccount {
  id: Int!
  nickname: String
  name: String
  email: String
  password: String!
  role: Role!
  botUsers(where: BotUserWhereInput, orderBy: BotUserOrderByInput): [BotUser!]!
  apps(where: AppWhereInput, orderBy: AppOrderByInput): [App!]!
  appCount: Int!
  appSubscriptions(where: AppSubscriptionWhereInput, orderBy: AppSubscriptionOrderByInput): [AppSubscription!]!
  requiresUpdate: UpdateRequiredPayload!
  createdAt: DateTime!
  updatedAt: DateTime!
}
enum Role {
  ADMIN
  USER
}
input BotUserWhereInput {
  id: IntFilter
  name: NullableStringFilter
  botUser: StringFilter
  botId: IntFilter
  userAccountId: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  AND: [BotUserWhereInput!]
  OR: [BotUserWhereInput!]
  NOT: [BotUserWhereInput!]
  bot: BotWhereInput
  userAccount: UserAccountWhereInput
}
input IntFilter {
  equals: Int
  not: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
}
input NullableStringFilter {
  equals: String
  not: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
}
input StringFilter {
  equals: String
  not: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
}
input DateTimeFilter {
  equals: DateTime
  not: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
}
input BotWhereInput {
  id: IntFilter
  type: BotType
  botUsers: BotUserFilter
  appSubscriptions: AppSubscriptionFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  AND: [BotWhereInput!]
  OR: [BotWhereInput!]
  NOT: [BotWhereInput!]
}
input BotUserFilter {
  every: BotUserWhereInput
  some: BotUserWhereInput
  none: BotUserWhereInput
}
input AppSubscriptionFilter {
  every: AppSubscriptionWhereInput
  some: AppSubscriptionWhereInput
  none: AppSubscriptionWhereInput
}
input AppSubscriptionWhereInput {
  id: IntFilter
  name: StringFilter
  customName: NullableStringFilter
  description: StringFilter
  muted: BooleanFilter
  mutedUntil: NullableDateTimeFilter
  environment: Environment
  appId: IntFilter
  subscriberId: IntFilter
  botId: IntFilter
  channel: StringFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  AND: [AppSubscriptionWhereInput!]
  OR: [AppSubscriptionWhereInput!]
  NOT: [AppSubscriptionWhereInput!]
  app: AppWhereInput
  subscriber: UserAccountWhereInput
  bot: BotWhereInput
}
input BooleanFilter {
  equals: Boolean
  not: Boolean
}
input NullableDateTimeFilter {
  equals: DateTime
  not: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
}
input AppWhereInput {
  id: IntFilter
  name: StringFilter
  disabled: BooleanFilter
  ownerId: IntFilter
  subscribeTokens: SubscribeTokenFilter
  appSubscriptions: AppSubscriptionFilter
  clientSecrets: ClientSecretFilter
  logs: AppLogFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  AND: [AppWhereInput!]
  OR: [AppWhereInput!]
  NOT: [AppWhereInput!]
  owner: UserAccountWhereInput
}
input SubscribeTokenFilter {
  every: SubscribeTokenWhereInput
  some: SubscribeTokenWhereInput
  none: SubscribeTokenWhereInput
}
input SubscribeTokenWhereInput {
  id: IntFilter
  description: StringFilter
  token: StringFilter
  appId: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  AND: [SubscribeTokenWhereInput!]
  OR: [SubscribeTokenWhereInput!]
  NOT: [SubscribeTokenWhereInput!]
  app: AppWhereInput
}
input ClientSecretFilter {
  every: ClientSecretWhereInput
  some: ClientSecretWhereInput
  none: ClientSecretWhereInput
}
input ClientSecretWhereInput {
  id: IntFilter
  environment: Environment
  secret: StringFilter
  appId: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  AND: [ClientSecretWhereInput!]
  OR: [ClientSecretWhereInput!]
  NOT: [ClientSecretWhereInput!]
  app: AppWhereInput
}
input AppLogFilter {
  every: AppLogWhereInput
  some: AppLogWhereInput
  none: AppLogWhereInput
}
input AppLogWhereInput {
  environment: Environment = PRODUCTION
  types: [AppLogType!] = [EVENT, LOG, STATUS]
  level: AppLogLevel
  state: AppState
}
enum AppLogType {
  EVENT
  LOG
  STATUS
}
enum AppLogLevel {
  INFO
  WARN
  ERROR
  FATAL
}
enum AppState {
  UNSET
  UP
  SHUTDOWN
  UNKNOWN
  CRITICAL
  DOWN
}
input UserAccountWhereInput {
  id: IntFilter
  nickname: NullableStringFilter
  name: NullableStringFilter
  email: NullableStringFilter
  password: NullableStringFilter
  role: Role
  botUsers: BotUserFilter
  apps: AppFilter
  appSubscriptions: AppSubscriptionFilter
  settings: UserAccountSettingsFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  AND: [UserAccountWhereInput!]
  OR: [UserAccountWhereInput!]
  NOT: [UserAccountWhereInput!]
}
input AppFilter {
  every: AppWhereInput
  some: AppWhereInput
  none: AppWhereInput
}
input UserAccountSettingsFilter {
  every: UserAccountSettingsWhereInput
  some: UserAccountSettingsWhereInput
  none: UserAccountSettingsWhereInput
}
input UserAccountSettingsWhereInput {
  id: IntFilter
  timezone: StringFilter
  userAccountId: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  AND: [UserAccountSettingsWhereInput!]
  OR: [UserAccountSettingsWhereInput!]
  NOT: [UserAccountSettingsWhereInput!]
  userAccount: UserAccountWhereInput
}
input BotUserOrderByInput {
  id: SortOrder
  name: SortOrder
  botUser: SortOrder
  botId: SortOrder
  userAccountId: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}
enum SortOrder {
  asc
  desc
}
input AppOrderByInput {
  id: SortOrder
  name: SortOrder
  disabled: SortOrder
  ownerId: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}
input AppSubscriptionOrderByInput {
  id: SortOrder
  name: SortOrder
  customName: SortOrder
  description: SortOrder
  muted: SortOrder
  mutedUntil: SortOrder
  environment: SortOrder
  appId: SortOrder
  subscriberId: SortOrder
  botId: SortOrder
  channel: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}
type UpdateRequiredPayload {
  required: Boolean!
  instant: Boolean!
  fields: [String!]!
}
input SubscribeTokenOrderByInput {
  id: SortOrder
  description: SortOrder
  token: SortOrder
  appId: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}
type SubscribeToken {
  id: Int!
  description: String!
  token: String!
  appId: Int!
  app: App!
  createdAt: DateTime!
  updatedAt: DateTime!
}
input ClientSecretOrderByInput {
  id: SortOrder
  environment: SortOrder
  secret: SortOrder
  appId: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}
type ClientSecret {
  id: Int!
  environment: Environment!
  secret: String!
  appId: Int!
  app: App!
  createdAt: DateTime!
  updatedAt: DateTime!
}
input AppLogWhereUniqueInput {
  id: Int
  appId_environment_level_message_timestamp: AppIdEnvironmentLevelMessageTimestampCompoundUniqueInput
}
input AppIdEnvironmentLevelMessageTimestampCompoundUniqueInput {
  appId: Int!
  environment: Environment!
  level: AppLogLevel!
  message: String!
  timestamp: DateTime!
}
interface AppLog {
  id: Int!
  type: AppLogType!
  level: AppLogLevel!
  message: String!
  metadata: Json
  timestamp: DateTime!
  environment: Environment!
  appId: Int!
  app: App!
  createdAt: DateTime!
  updatedAt: DateTime!
}
"""The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."""
scalar Json
input AppMetricsWhereInput {
  period: AppMetricsPeriod = MONTH
  before: Int = 0
}
enum AppMetricsPeriod {
  DAY
  WEEK
  MONTH
}
type AppMetrics {
  start: DateTime!
  end: DateTime!
  events: Int!
  logs: Int!
  statuses: Int!
  limit: Int!
}
input AppStatusWhereInput {
  environment: Environment = PRODUCTION
  states: [AppState!] = [UNSET, UP, SHUTDOWN, UNKNOWN, CRITICAL, DOWN]
}
type AppStatus {
  state: AppState!
  since: DateTime!
}
input AppStatusWhereUniqueInput {
  id: Int
}
input ClientSecretWhereUniqueInput {
  id: Int
  secret: String
  environment_appId: EnvironmentAppIdCompoundUniqueInput
}
input EnvironmentAppIdCompoundUniqueInput {
  environment: Environment!
  appId: Int!
}
input SubscribeTokenWhereUniqueInput {
  id: Int
  token: String
  description_appId: DescriptionAppIdCompoundUniqueInput
}
input DescriptionAppIdCompoundUniqueInput {
  description: String!
  appId: Int!
}
input UserAccountWhereUniqueInput {
  id: Int
  nickname: String
}
input UserAccountOrderByInput {
  id: SortOrder
  nickname: SortOrder
  name: SortOrder
  email: SortOrder
  password: SortOrder
  role: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}
input AppWhereUniqueInput {
  id: Int
  name_ownerId: NameOwnerIdCompoundUniqueInput
}
input NameOwnerIdCompoundUniqueInput {
  name: String!
  ownerId: Int!
}
type Mutation {
  signUp(data: SignUpInput!): UserAccountAndToken!
  signIn(data: SignInInput!): UserAccountAndToken!
  signInViaBot(data: SignInViaBotInput!): UserAccountAndToken!
  generateBotToken(data: GenerateBotTokenInput!): GenerateBotTokenPayload!
  updateBotUser(data: BotUserUpdateInput!, where: BotUserWhereUniqueInput!): BotUser
  regenerateClientSecret(where: ClientSecretRegenerateInput!): ClientSecret!
  createSubscribeToken(data: SubscribeTokenCreateInput!): SubscribeToken!
  deleteSubscribeToken(where: DeleteByIdInput!): SubscribeToken!
  updateUserAccount(data: UserAccountUpdateInput!, where: UserAccountWhereUniqueInput!): UserAccount
  deleteUserAccount(where: DeleteByIdInput!): UserAccount!
  createApp(data: AppCreateInput!): App!
  deleteApp(where: DeleteByIdInput!): App!
  createAppSubscription(data: AppSubscriptionCreateInput!): AppSubscription!
  muteAppSubscription(where: UpdateByIdInput!, data: AppSubscriptionMuteInput): AppSubscription!
  unmuteAppSubscription(where: UpdateByIdInput!): AppSubscription!
  deleteAppSubscription(where: DeleteByIdInput!): AppSubscription!
  sendEventLog(data: EventLogSendInput!): ClientResponse!
  sendLog(data: LogSendInput!): ClientResponse!
  sendStatusLog(data: StatusLogSendInput!): ClientResponse!
}
input SignUpInput {
  nickname: String!
  name: String!
  email: String!
  password: String!
}
type UserAccountAndToken {
  userAccount: UserAccount!
  token: String!
}
input SignInInput {
  nickname: String!
  password: String!
}
input SignInViaBotInput {
  botUser: String!
}
input GenerateBotTokenInput {
  bot: BotType!
}
type GenerateBotTokenPayload {
  token: String!
}
input BotUserUpdateInput {
  name: String
}
input ClientSecretRegenerateInput {
  id: Int!
}
input SubscribeTokenCreateInput {
  description: String!
  appId: Int!
}
input DeleteByIdInput {
  id: Int!
}
input UserAccountUpdateInput {
  nickname: String
  name: String
  email: String
  password: String
  role: Role
  apps: AppUpdateManyWithoutOwnerInput
  appSubscriptions: AppSubscriptionUpdateManyWithoutSubscriberInput
  settings: UserAccountSettingsUpdateManyWithoutUserAccountInput
}
input AppUpdateManyWithoutOwnerInput {
  create: [AppCreateWithoutOwnerInput!]
  connect: [AppWhereUniqueInput!]
  set: [AppWhereUniqueInput!]
  disconnect: [AppWhereUniqueInput!]
  delete: [AppWhereUniqueInput!]
  update: [AppUpdateWithWhereUniqueWithoutOwnerInput!]
  updateMany: [AppUpdateManyWithWhereNestedInput!]
  deleteMany: [AppScalarWhereInput!]
  upsert: [AppUpsertWithWhereUniqueWithoutOwnerInput!]
}
input AppCreateWithoutOwnerInput {
  name: String!
  disabled: Boolean
  createdAt: DateTime
  updatedAt: DateTime
  subscribeTokens: SubscribeTokenCreateManyWithoutAppInput
  appSubscriptions: AppSubscriptionCreateManyWithoutAppInput
  clientSecrets: ClientSecretCreateManyWithoutAppInput
  logs: AppLogCreateManyWithoutAppInput
}
input SubscribeTokenCreateManyWithoutAppInput {
  create: [SubscribeTokenCreateWithoutAppInput!]
  connect: [SubscribeTokenWhereUniqueInput!]
}
input SubscribeTokenCreateWithoutAppInput {
  description: String!
  token: String!
  createdAt: DateTime
  updatedAt: DateTime
}
input AppSubscriptionCreateManyWithoutAppInput {
  create: [AppSubscriptionCreateWithoutAppInput!]
  connect: [AppSubscriptionWhereUniqueInput!]
}
input AppSubscriptionCreateWithoutAppInput {
  name: String!
  customName: String
  description: String!
  muted: Boolean
  mutedUntil: DateTime
  environment: Environment
  channel: String!
  createdAt: DateTime
  updatedAt: DateTime
  subscriber: UserAccountCreateOneWithoutAppSubscriptionsInput!
  bot: BotCreateOneWithoutAppSubscriptionsInput!
}
input UserAccountCreateOneWithoutAppSubscriptionsInput {
  create: UserAccountCreateWithoutAppSubscriptionsInput
  connect: UserAccountWhereUniqueInput
}
input UserAccountCreateWithoutAppSubscriptionsInput {
  nickname: String
  name: String
  email: String
  password: String
  role: Role
  createdAt: DateTime
  updatedAt: DateTime
  botUsers: BotUserCreateManyWithoutUserAccountInput
  apps: AppCreateManyWithoutOwnerInput
  settings: UserAccountSettingsCreateManyWithoutUserAccountInput
}
input BotUserCreateManyWithoutUserAccountInput {
  create: [BotUserCreateWithoutUserAccountInput!]
  connect: [BotUserWhereUniqueInput!]
}
input BotUserCreateWithoutUserAccountInput {
  name: String
  botUser: String!
  createdAt: DateTime
  updatedAt: DateTime
  bot: BotCreateOneWithoutBotUsersInput!
}
input BotCreateOneWithoutBotUsersInput {
  create: BotCreateWithoutBotUsersInput
  connect: BotWhereUniqueInput
}
input BotCreateWithoutBotUsersInput {
  type: BotType!
  createdAt: DateTime
  updatedAt: DateTime
  appSubscriptions: AppSubscriptionCreateManyWithoutBotInput
}
input AppSubscriptionCreateManyWithoutBotInput {
  create: [AppSubscriptionCreateWithoutBotInput!]
  connect: [AppSubscriptionWhereUniqueInput!]
}
input AppSubscriptionCreateWithoutBotInput {
  name: String!
  customName: String
  description: String!
  muted: Boolean
  mutedUntil: DateTime
  environment: Environment
  channel: String!
  createdAt: DateTime
  updatedAt: DateTime
  app: AppCreateOneWithoutAppSubscriptionsInput!
  subscriber: UserAccountCreateOneWithoutAppSubscriptionsInput!
}
input AppCreateOneWithoutAppSubscriptionsInput {
  create: AppCreateWithoutAppSubscriptionsInput
  connect: AppWhereUniqueInput
}
input AppCreateWithoutAppSubscriptionsInput {
  name: String!
  disabled: Boolean
  createdAt: DateTime
  updatedAt: DateTime
  owner: UserAccountCreateOneWithoutAppsInput!
  subscribeTokens: SubscribeTokenCreateManyWithoutAppInput
  clientSecrets: ClientSecretCreateManyWithoutAppInput
  logs: AppLogCreateManyWithoutAppInput
}
input UserAccountCreateOneWithoutAppsInput {
  create: UserAccountCreateWithoutAppsInput
  connect: UserAccountWhereUniqueInput
}
input UserAccountCreateWithoutAppsInput {
  nickname: String
  name: String
  email: String
  password: String
  role: Role
  createdAt: DateTime
  updatedAt: DateTime
  botUsers: BotUserCreateManyWithoutUserAccountInput
  appSubscriptions: AppSubscriptionCreateManyWithoutSubscriberInput
  settings: UserAccountSettingsCreateManyWithoutUserAccountInput
}
input AppSubscriptionCreateManyWithoutSubscriberInput {
  create: [AppSubscriptionCreateWithoutSubscriberInput!]
  connect: [AppSubscriptionWhereUniqueInput!]
}
input AppSubscriptionCreateWithoutSubscriberInput {
  name: String!
  customName: String
  description: String!
  muted: Boolean
  mutedUntil: DateTime
  environment: Environment
  channel: String!
  createdAt: DateTime
  updatedAt: DateTime
  app: AppCreateOneWithoutAppSubscriptionsInput!
  bot: BotCreateOneWithoutAppSubscriptionsInput!
}
input BotCreateOneWithoutAppSubscriptionsInput {
  create: BotCreateWithoutAppSubscriptionsInput
  connect: BotWhereUniqueInput
}
input BotCreateWithoutAppSubscriptionsInput {
  type: BotType!
  createdAt: DateTime
  updatedAt: DateTime
  botUsers: BotUserCreateManyWithoutBotInput
}
input BotUserCreateManyWithoutBotInput {
  create: [BotUserCreateWithoutBotInput!]
  connect: [BotUserWhereUniqueInput!]
}
input BotUserCreateWithoutBotInput {
  name: String
  botUser: String!
  createdAt: DateTime
  updatedAt: DateTime
  userAccount: UserAccountCreateOneWithoutBotUsersInput!
}
input UserAccountCreateOneWithoutBotUsersInput {
  create: UserAccountCreateWithoutBotUsersInput
  connect: UserAccountWhereUniqueInput
}
input UserAccountCreateWithoutBotUsersInput {
  nickname: String
  name: String
  email: String
  password: String
  role: Role
  createdAt: DateTime
  updatedAt: DateTime
  apps: AppCreateManyWithoutOwnerInput
  appSubscriptions: AppSubscriptionCreateManyWithoutSubscriberInput
  settings: UserAccountSettingsCreateManyWithoutUserAccountInput
}
input AppCreateManyWithoutOwnerInput {
  create: [AppCreateWithoutOwnerInput!]
  connect: [AppWhereUniqueInput!]
}
input UserAccountSettingsCreateManyWithoutUserAccountInput {
  create: [UserAccountSettingsCreateWithoutUserAccountInput!]
  connect: [UserAccountSettingsWhereUniqueInput!]
}
input UserAccountSettingsCreateWithoutUserAccountInput {
  timezone: String
  createdAt: DateTime
  updatedAt: DateTime
}
input UserAccountSettingsWhereUniqueInput {
  id: Int
}
input BotWhereUniqueInput {
  id: Int
  type: BotType
}
input ClientSecretCreateManyWithoutAppInput {
  create: [ClientSecretCreateWithoutAppInput!]
  connect: [ClientSecretWhereUniqueInput!]
}
input ClientSecretCreateWithoutAppInput {
  environment: Environment!
  secret: String!
  createdAt: DateTime
  updatedAt: DateTime
}
input AppLogCreateManyWithoutAppInput {
  create: [AppLogCreateWithoutAppInput!]
  connect: [AppLogWhereUniqueInput!]
}
input AppLogCreateWithoutAppInput {
  type: AppLogType!
  level: AppLogLevel
  message: String!
  state: AppState
  metadata: Json
  timestamp: DateTime
  environment: Environment!
  createdAt: DateTime
  updatedAt: DateTime
  event: AppLogEventExtCreateOneWithoutLogInput
}
input AppLogEventExtCreateOneWithoutLogInput {
  create: AppLogEventExtCreateWithoutLogInput
  connect: AppLogEventExtWhereUniqueInput
}
input AppLogEventExtCreateWithoutLogInput {
  category: AppLogEventExtCategory
  title: String!
}
enum AppLogEventExtCategory {
  NONE
  POST
  NEWS
  PAYMENT
  MAIL
  TRAIN
  TRAVELLING
  CAR
  INDUSTRY
  MUSIC
  VIDEO
  MOVIE
}
input AppLogEventExtWhereUniqueInput {
  id: Int
}
input AppUpdateWithWhereUniqueWithoutOwnerInput {
  where: AppWhereUniqueInput!
  data: AppUpdateWithoutOwnerDataInput!
}
input AppUpdateWithoutOwnerDataInput {
  name: String
  disabled: Boolean
  createdAt: DateTime
  updatedAt: DateTime
  subscribeTokens: SubscribeTokenUpdateManyWithoutAppInput
  appSubscriptions: AppSubscriptionUpdateManyWithoutAppInput
  clientSecrets: ClientSecretUpdateManyWithoutAppInput
  logs: AppLogUpdateManyWithoutAppInput
}
input SubscribeTokenUpdateManyWithoutAppInput {
  create: [SubscribeTokenCreateWithoutAppInput!]
  connect: [SubscribeTokenWhereUniqueInput!]
  set: [SubscribeTokenWhereUniqueInput!]
  disconnect: [SubscribeTokenWhereUniqueInput!]
  delete: [SubscribeTokenWhereUniqueInput!]
  update: [SubscribeTokenUpdateWithWhereUniqueWithoutAppInput!]
  updateMany: [SubscribeTokenUpdateManyWithWhereNestedInput!]
  deleteMany: [SubscribeTokenScalarWhereInput!]
  upsert: [SubscribeTokenUpsertWithWhereUniqueWithoutAppInput!]
}
input SubscribeTokenUpdateWithWhereUniqueWithoutAppInput {
  where: SubscribeTokenWhereUniqueInput!
  data: SubscribeTokenUpdateWithoutAppDataInput!
}
input SubscribeTokenUpdateWithoutAppDataInput {
  description: String
  token: String
  createdAt: DateTime
  updatedAt: DateTime
}
input SubscribeTokenUpdateManyWithWhereNestedInput {
  where: SubscribeTokenScalarWhereInput!
  data: SubscribeTokenUpdateManyDataInput!
}
input SubscribeTokenScalarWhereInput {
  id: IntFilter
  description: StringFilter
  token: StringFilter
  appId: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  AND: [SubscribeTokenScalarWhereInput!]
  OR: [SubscribeTokenScalarWhereInput!]
  NOT: [SubscribeTokenScalarWhereInput!]
}
input SubscribeTokenUpdateManyDataInput {
  description: String
  token: String
  createdAt: DateTime
  updatedAt: DateTime
}
input SubscribeTokenUpsertWithWhereUniqueWithoutAppInput {
  where: SubscribeTokenWhereUniqueInput!
  update: SubscribeTokenUpdateWithoutAppDataInput!
  create: SubscribeTokenCreateWithoutAppInput!
}
input AppSubscriptionUpdateManyWithoutAppInput {
  create: [AppSubscriptionCreateWithoutAppInput!]
  connect: [AppSubscriptionWhereUniqueInput!]
  set: [AppSubscriptionWhereUniqueInput!]
  disconnect: [AppSubscriptionWhereUniqueInput!]
  delete: [AppSubscriptionWhereUniqueInput!]
  update: [AppSubscriptionUpdateWithWhereUniqueWithoutAppInput!]
  updateMany: [AppSubscriptionUpdateManyWithWhereNestedInput!]
  deleteMany: [AppSubscriptionScalarWhereInput!]
  upsert: [AppSubscriptionUpsertWithWhereUniqueWithoutAppInput!]
}
input AppSubscriptionUpdateWithWhereUniqueWithoutAppInput {
  where: AppSubscriptionWhereUniqueInput!
  data: AppSubscriptionUpdateWithoutAppDataInput!
}
input AppSubscriptionUpdateWithoutAppDataInput {
  name: String
  customName: String
  description: String
  muted: Boolean
  mutedUntil: DateTime
  environment: Environment
  channel: String
  createdAt: DateTime
  updatedAt: DateTime
  subscriber: UserAccountUpdateOneRequiredWithoutAppSubscriptionsInput
  bot: BotUpdateOneRequiredWithoutAppSubscriptionsInput
}
input UserAccountUpdateOneRequiredWithoutAppSubscriptionsInput {
  create: UserAccountCreateWithoutAppSubscriptionsInput
  connect: UserAccountWhereUniqueInput
  update: UserAccountUpdateWithoutAppSubscriptionsDataInput
  upsert: UserAccountUpsertWithoutAppSubscriptionsInput
}
input UserAccountUpdateWithoutAppSubscriptionsDataInput {
  nickname: String
  name: String
  email: String
  password: String
  role: Role
  createdAt: DateTime
  updatedAt: DateTime
  botUsers: BotUserUpdateManyWithoutUserAccountInput
  apps: AppUpdateManyWithoutOwnerInput
  settings: UserAccountSettingsUpdateManyWithoutUserAccountInput
}
input BotUserUpdateManyWithoutUserAccountInput {
  create: [BotUserCreateWithoutUserAccountInput!]
  connect: [BotUserWhereUniqueInput!]
  set: [BotUserWhereUniqueInput!]
  disconnect: [BotUserWhereUniqueInput!]
  delete: [BotUserWhereUniqueInput!]
  update: [BotUserUpdateWithWhereUniqueWithoutUserAccountInput!]
  updateMany: [BotUserUpdateManyWithWhereNestedInput!]
  deleteMany: [BotUserScalarWhereInput!]
  upsert: [BotUserUpsertWithWhereUniqueWithoutUserAccountInput!]
}
input BotUserUpdateWithWhereUniqueWithoutUserAccountInput {
  where: BotUserWhereUniqueInput!
  data: BotUserUpdateWithoutUserAccountDataInput!
}
input BotUserUpdateWithoutUserAccountDataInput {
  name: String
  botUser: String
  createdAt: DateTime
  updatedAt: DateTime
  bot: BotUpdateOneRequiredWithoutBotUsersInput
}
input BotUpdateOneRequiredWithoutBotUsersInput {
  create: BotCreateWithoutBotUsersInput
  connect: BotWhereUniqueInput
  update: BotUpdateWithoutBotUsersDataInput
  upsert: BotUpsertWithoutBotUsersInput
}
input BotUpdateWithoutBotUsersDataInput {
  type: BotType
  createdAt: DateTime
  updatedAt: DateTime
  appSubscriptions: AppSubscriptionUpdateManyWithoutBotInput
}
input AppSubscriptionUpdateManyWithoutBotInput {
  create: [AppSubscriptionCreateWithoutBotInput!]
  connect: [AppSubscriptionWhereUniqueInput!]
  set: [AppSubscriptionWhereUniqueInput!]
  disconnect: [AppSubscriptionWhereUniqueInput!]
  delete: [AppSubscriptionWhereUniqueInput!]
  update: [AppSubscriptionUpdateWithWhereUniqueWithoutBotInput!]
  updateMany: [AppSubscriptionUpdateManyWithWhereNestedInput!]
  deleteMany: [AppSubscriptionScalarWhereInput!]
  upsert: [AppSubscriptionUpsertWithWhereUniqueWithoutBotInput!]
}
input AppSubscriptionUpdateWithWhereUniqueWithoutBotInput {
  where: AppSubscriptionWhereUniqueInput!
  data: AppSubscriptionUpdateWithoutBotDataInput!
}
input AppSubscriptionUpdateWithoutBotDataInput {
  name: String
  customName: String
  description: String
  muted: Boolean
  mutedUntil: DateTime
  environment: Environment
  channel: String
  createdAt: DateTime
  updatedAt: DateTime
  app: AppUpdateOneRequiredWithoutAppSubscriptionsInput
  subscriber: UserAccountUpdateOneRequiredWithoutAppSubscriptionsInput
}
input AppUpdateOneRequiredWithoutAppSubscriptionsInput {
  create: AppCreateWithoutAppSubscriptionsInput
  connect: AppWhereUniqueInput
  update: AppUpdateWithoutAppSubscriptionsDataInput
  upsert: AppUpsertWithoutAppSubscriptionsInput
}
input AppUpdateWithoutAppSubscriptionsDataInput {
  name: String
  disabled: Boolean
  createdAt: DateTime
  updatedAt: DateTime
  owner: UserAccountUpdateOneRequiredWithoutAppsInput
  subscribeTokens: SubscribeTokenUpdateManyWithoutAppInput
  clientSecrets: ClientSecretUpdateManyWithoutAppInput
  logs: AppLogUpdateManyWithoutAppInput
}
input UserAccountUpdateOneRequiredWithoutAppsInput {
  create: UserAccountCreateWithoutAppsInput
  connect: UserAccountWhereUniqueInput
  update: UserAccountUpdateWithoutAppsDataInput
  upsert: UserAccountUpsertWithoutAppsInput
}
input UserAccountUpdateWithoutAppsDataInput {
  nickname: String
  name: String
  email: String
  password: String
  role: Role
  createdAt: DateTime
  updatedAt: DateTime
  botUsers: BotUserUpdateManyWithoutUserAccountInput
  appSubscriptions: AppSubscriptionUpdateManyWithoutSubscriberInput
  settings: UserAccountSettingsUpdateManyWithoutUserAccountInput
}
input AppSubscriptionUpdateManyWithoutSubscriberInput {
  create: [AppSubscriptionCreateWithoutSubscriberInput!]
  connect: [AppSubscriptionWhereUniqueInput!]
  set: [AppSubscriptionWhereUniqueInput!]
  disconnect: [AppSubscriptionWhereUniqueInput!]
  delete: [AppSubscriptionWhereUniqueInput!]
  update: [AppSubscriptionUpdateWithWhereUniqueWithoutSubscriberInput!]
  updateMany: [AppSubscriptionUpdateManyWithWhereNestedInput!]
  deleteMany: [AppSubscriptionScalarWhereInput!]
  upsert: [AppSubscriptionUpsertWithWhereUniqueWithoutSubscriberInput!]
}
input AppSubscriptionUpdateWithWhereUniqueWithoutSubscriberInput {
  where: AppSubscriptionWhereUniqueInput!
  data: AppSubscriptionUpdateWithoutSubscriberDataInput!
}
input AppSubscriptionUpdateWithoutSubscriberDataInput {
  name: String
  customName: String
  description: String
  muted: Boolean
  mutedUntil: DateTime
  environment: Environment
  channel: String
  createdAt: DateTime
  updatedAt: DateTime
  app: AppUpdateOneRequiredWithoutAppSubscriptionsInput
  bot: BotUpdateOneRequiredWithoutAppSubscriptionsInput
}
input BotUpdateOneRequiredWithoutAppSubscriptionsInput {
  create: BotCreateWithoutAppSubscriptionsInput
  connect: BotWhereUniqueInput
  update: BotUpdateWithoutAppSubscriptionsDataInput
  upsert: BotUpsertWithoutAppSubscriptionsInput
}
input BotUpdateWithoutAppSubscriptionsDataInput {
  type: BotType
  createdAt: DateTime
  updatedAt: DateTime
  botUsers: BotUserUpdateManyWithoutBotInput
}
input BotUserUpdateManyWithoutBotInput {
  create: [BotUserCreateWithoutBotInput!]
  connect: [BotUserWhereUniqueInput!]
  set: [BotUserWhereUniqueInput!]
  disconnect: [BotUserWhereUniqueInput!]
  delete: [BotUserWhereUniqueInput!]
  update: [BotUserUpdateWithWhereUniqueWithoutBotInput!]
  updateMany: [BotUserUpdateManyWithWhereNestedInput!]
  deleteMany: [BotUserScalarWhereInput!]
  upsert: [BotUserUpsertWithWhereUniqueWithoutBotInput!]
}
input BotUserUpdateWithWhereUniqueWithoutBotInput {
  where: BotUserWhereUniqueInput!
  data: BotUserUpdateWithoutBotDataInput!
}
input BotUserUpdateWithoutBotDataInput {
  name: String
  botUser: String
  createdAt: DateTime
  updatedAt: DateTime
  userAccount: UserAccountUpdateOneRequiredWithoutBotUsersInput
}
input UserAccountUpdateOneRequiredWithoutBotUsersInput {
  create: UserAccountCreateWithoutBotUsersInput
  connect: UserAccountWhereUniqueInput
  update: UserAccountUpdateWithoutBotUsersDataInput
  upsert: UserAccountUpsertWithoutBotUsersInput
}
input UserAccountUpdateWithoutBotUsersDataInput {
  nickname: String
  name: String
  email: String
  password: String
  role: Role
  createdAt: DateTime
  updatedAt: DateTime
  apps: AppUpdateManyWithoutOwnerInput
  appSubscriptions: AppSubscriptionUpdateManyWithoutSubscriberInput
  settings: UserAccountSettingsUpdateManyWithoutUserAccountInput
}
input UserAccountSettingsUpdateManyWithoutUserAccountInput {
  create: [UserAccountSettingsCreateWithoutUserAccountInput!]
  connect: [UserAccountSettingsWhereUniqueInput!]
  set: [UserAccountSettingsWhereUniqueInput!]
  disconnect: [UserAccountSettingsWhereUniqueInput!]
  delete: [UserAccountSettingsWhereUniqueInput!]
  update: [UserAccountSettingsUpdateWithWhereUniqueWithoutUserAccountInput!]
  updateMany: [UserAccountSettingsUpdateManyWithWhereNestedInput!]
  deleteMany: [UserAccountSettingsScalarWhereInput!]
  upsert: [UserAccountSettingsUpsertWithWhereUniqueWithoutUserAccountInput!]
}
input UserAccountSettingsUpdateWithWhereUniqueWithoutUserAccountInput {
  where: UserAccountSettingsWhereUniqueInput!
  data: UserAccountSettingsUpdateWithoutUserAccountDataInput!
}
input UserAccountSettingsUpdateWithoutUserAccountDataInput {
  timezone: String
  createdAt: DateTime
  updatedAt: DateTime
}
input UserAccountSettingsUpdateManyWithWhereNestedInput {
  where: UserAccountSettingsScalarWhereInput!
  data: UserAccountSettingsUpdateManyDataInput!
}
input UserAccountSettingsScalarWhereInput {
  id: IntFilter
  timezone: StringFilter
  userAccountId: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  AND: [UserAccountSettingsScalarWhereInput!]
  OR: [UserAccountSettingsScalarWhereInput!]
  NOT: [UserAccountSettingsScalarWhereInput!]
}
input UserAccountSettingsUpdateManyDataInput {
  timezone: String
  createdAt: DateTime
  updatedAt: DateTime
}
input UserAccountSettingsUpsertWithWhereUniqueWithoutUserAccountInput {
  where: UserAccountSettingsWhereUniqueInput!
  update: UserAccountSettingsUpdateWithoutUserAccountDataInput!
  create: UserAccountSettingsCreateWithoutUserAccountInput!
}
input UserAccountUpsertWithoutBotUsersInput {
  update: UserAccountUpdateWithoutBotUsersDataInput!
  create: UserAccountCreateWithoutBotUsersInput!
}
input BotUserUpdateManyWithWhereNestedInput {
  where: BotUserScalarWhereInput!
  data: BotUserUpdateManyDataInput!
}
input BotUserScalarWhereInput {
  id: IntFilter
  name: NullableStringFilter
  botUser: StringFilter
  botId: IntFilter
  userAccountId: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  AND: [BotUserScalarWhereInput!]
  OR: [BotUserScalarWhereInput!]
  NOT: [BotUserScalarWhereInput!]
}
input BotUserUpdateManyDataInput {
  name: String
  botUser: String
  createdAt: DateTime
  updatedAt: DateTime
}
input BotUserUpsertWithWhereUniqueWithoutBotInput {
  where: BotUserWhereUniqueInput!
  update: BotUserUpdateWithoutBotDataInput!
  create: BotUserCreateWithoutBotInput!
}
input BotUpsertWithoutAppSubscriptionsInput {
  update: BotUpdateWithoutAppSubscriptionsDataInput!
  create: BotCreateWithoutAppSubscriptionsInput!
}
input AppSubscriptionUpdateManyWithWhereNestedInput {
  where: AppSubscriptionScalarWhereInput!
  data: AppSubscriptionUpdateManyDataInput!
}
input AppSubscriptionScalarWhereInput {
  id: IntFilter
  name: StringFilter
  customName: NullableStringFilter
  description: StringFilter
  muted: BooleanFilter
  mutedUntil: NullableDateTimeFilter
  environment: Environment
  appId: IntFilter
  subscriberId: IntFilter
  botId: IntFilter
  channel: StringFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  AND: [AppSubscriptionScalarWhereInput!]
  OR: [AppSubscriptionScalarWhereInput!]
  NOT: [AppSubscriptionScalarWhereInput!]
}
input AppSubscriptionUpdateManyDataInput {
  name: String
  customName: String
  description: String
  muted: Boolean
  mutedUntil: DateTime
  environment: Environment
  channel: String
  createdAt: DateTime
  updatedAt: DateTime
}
input AppSubscriptionUpsertWithWhereUniqueWithoutSubscriberInput {
  where: AppSubscriptionWhereUniqueInput!
  update: AppSubscriptionUpdateWithoutSubscriberDataInput!
  create: AppSubscriptionCreateWithoutSubscriberInput!
}
input UserAccountUpsertWithoutAppsInput {
  update: UserAccountUpdateWithoutAppsDataInput!
  create: UserAccountCreateWithoutAppsInput!
}
input ClientSecretUpdateManyWithoutAppInput {
  create: [ClientSecretCreateWithoutAppInput!]
  connect: [ClientSecretWhereUniqueInput!]
  set: [ClientSecretWhereUniqueInput!]
  disconnect: [ClientSecretWhereUniqueInput!]
  delete: [ClientSecretWhereUniqueInput!]
  update: [ClientSecretUpdateWithWhereUniqueWithoutAppInput!]
  updateMany: [ClientSecretUpdateManyWithWhereNestedInput!]
  deleteMany: [ClientSecretScalarWhereInput!]
  upsert: [ClientSecretUpsertWithWhereUniqueWithoutAppInput!]
}
input ClientSecretUpdateWithWhereUniqueWithoutAppInput {
  where: ClientSecretWhereUniqueInput!
  data: ClientSecretUpdateWithoutAppDataInput!
}
input ClientSecretUpdateWithoutAppDataInput {
  environment: Environment
  secret: String
  createdAt: DateTime
  updatedAt: DateTime
}
input ClientSecretUpdateManyWithWhereNestedInput {
  where: ClientSecretScalarWhereInput!
  data: ClientSecretUpdateManyDataInput!
}
input ClientSecretScalarWhereInput {
  id: IntFilter
  environment: Environment
  secret: StringFilter
  appId: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  AND: [ClientSecretScalarWhereInput!]
  OR: [ClientSecretScalarWhereInput!]
  NOT: [ClientSecretScalarWhereInput!]
}
input ClientSecretUpdateManyDataInput {
  environment: Environment
  secret: String
  createdAt: DateTime
  updatedAt: DateTime
}
input ClientSecretUpsertWithWhereUniqueWithoutAppInput {
  where: ClientSecretWhereUniqueInput!
  update: ClientSecretUpdateWithoutAppDataInput!
  create: ClientSecretCreateWithoutAppInput!
}
input AppLogUpdateManyWithoutAppInput {
  create: [AppLogCreateWithoutAppInput!]
  connect: [AppLogWhereUniqueInput!]
  set: [AppLogWhereUniqueInput!]
  disconnect: [AppLogWhereUniqueInput!]
  delete: [AppLogWhereUniqueInput!]
  update: [AppLogUpdateWithWhereUniqueWithoutAppInput!]
  updateMany: [AppLogUpdateManyWithWhereNestedInput!]
  deleteMany: [AppLogScalarWhereInput!]
  upsert: [AppLogUpsertWithWhereUniqueWithoutAppInput!]
}
input AppLogUpdateWithWhereUniqueWithoutAppInput {
  where: AppLogWhereUniqueInput!
  data: AppLogUpdateWithoutAppDataInput!
}
input AppLogUpdateWithoutAppDataInput {
  type: AppLogType
  level: AppLogLevel
  message: String
  state: AppState
  metadata: Json
  timestamp: DateTime
  environment: Environment
  createdAt: DateTime
  updatedAt: DateTime
  event: AppLogEventExtUpdateOneWithoutLogInput
}
input AppLogEventExtUpdateOneWithoutLogInput {
  create: AppLogEventExtCreateWithoutLogInput
  connect: AppLogEventExtWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: AppLogEventExtUpdateWithoutLogDataInput
  upsert: AppLogEventExtUpsertWithoutLogInput
}
input AppLogEventExtUpdateWithoutLogDataInput {
  category: AppLogEventExtCategory
  title: String
}
input AppLogEventExtUpsertWithoutLogInput {
  update: AppLogEventExtUpdateWithoutLogDataInput!
  create: AppLogEventExtCreateWithoutLogInput!
}
input AppLogUpdateManyWithWhereNestedInput {
  where: AppLogScalarWhereInput!
  data: AppLogUpdateManyDataInput!
}
input AppLogScalarWhereInput {
  id: IntFilter
  type: AppLogType
  level: AppLogLevel
  message: StringFilter
  state: AppState
  timestamp: DateTimeFilter
  environment: Environment
  appId: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  AND: [AppLogScalarWhereInput!]
  OR: [AppLogScalarWhereInput!]
  NOT: [AppLogScalarWhereInput!]
}
input AppLogUpdateManyDataInput {
  type: AppLogType
  level: AppLogLevel
  message: String
  state: AppState
  metadata: Json
  timestamp: DateTime
  environment: Environment
  createdAt: DateTime
  updatedAt: DateTime
}
input AppLogUpsertWithWhereUniqueWithoutAppInput {
  where: AppLogWhereUniqueInput!
  update: AppLogUpdateWithoutAppDataInput!
  create: AppLogCreateWithoutAppInput!
}
input AppUpsertWithoutAppSubscriptionsInput {
  update: AppUpdateWithoutAppSubscriptionsDataInput!
  create: AppCreateWithoutAppSubscriptionsInput!
}
input AppSubscriptionUpsertWithWhereUniqueWithoutBotInput {
  where: AppSubscriptionWhereUniqueInput!
  update: AppSubscriptionUpdateWithoutBotDataInput!
  create: AppSubscriptionCreateWithoutBotInput!
}
input BotUpsertWithoutBotUsersInput {
  update: BotUpdateWithoutBotUsersDataInput!
  create: BotCreateWithoutBotUsersInput!
}
input BotUserUpsertWithWhereUniqueWithoutUserAccountInput {
  where: BotUserWhereUniqueInput!
  update: BotUserUpdateWithoutUserAccountDataInput!
  create: BotUserCreateWithoutUserAccountInput!
}
input UserAccountUpsertWithoutAppSubscriptionsInput {
  update: UserAccountUpdateWithoutAppSubscriptionsDataInput!
  create: UserAccountCreateWithoutAppSubscriptionsInput!
}
input AppSubscriptionUpsertWithWhereUniqueWithoutAppInput {
  where: AppSubscriptionWhereUniqueInput!
  update: AppSubscriptionUpdateWithoutAppDataInput!
  create: AppSubscriptionCreateWithoutAppInput!
}
input AppUpdateManyWithWhereNestedInput {
  where: AppScalarWhereInput!
  data: AppUpdateManyDataInput!
}
input AppScalarWhereInput {
  id: IntFilter
  name: StringFilter
  disabled: BooleanFilter
  ownerId: IntFilter
  subscribeTokens: SubscribeTokenFilter
  appSubscriptions: AppSubscriptionFilter
  clientSecrets: ClientSecretFilter
  logs: AppLogFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  AND: [AppScalarWhereInput!]
  OR: [AppScalarWhereInput!]
  NOT: [AppScalarWhereInput!]
}
input AppUpdateManyDataInput {
  name: String
  disabled: Boolean
  createdAt: DateTime
  updatedAt: DateTime
}
input AppUpsertWithWhereUniqueWithoutOwnerInput {
  where: AppWhereUniqueInput!
  update: AppUpdateWithoutOwnerDataInput!
  create: AppCreateWithoutOwnerInput!
}
input AppCreateInput {
  name: String!
}
input AppSubscriptionCreateInput {
  name: String!
  channel: String!
  subscribeToken: String!
  userToken: String!
  environment: Environment
}
input UpdateByIdInput {
  id: Int!
}
input AppSubscriptionMuteInput {
  muteUntil: DateTime
}
input EventLogSendInput {
  title: String!
  category: AppLogEventExtCategory
  message: String!
  metadata: Json
  timestamp: DateTime!
}
type ClientResponse {
  success: Boolean!
}
input LogSendInput {
  level: AppLogLevel!
  message: String!
  metadata: Json
  timestamp: DateTime!
}
input StatusLogSendInput {
  state: AppState!
  message: String!
  metadata: Json
  timestamp: DateTime!
}
type Subscription {
  appLog(app: Int!): AppLog!
}
enum BotJobType {
  EVENT_LOG
  LOG
  STATUS_LOG
}
interface BotJob {
  type: BotJobType!
  bot: BotType!
  channel: String!
}
type EventLogJob implements BotJob {
  type: BotJobType!
  bot: BotType!
  channel: String!
  level: AppLogLevel!
  title: String!
  category: AppLogEventExtCategory
  message: String!
  metadata: Json
  timestamp: DateTime!
  status: AppState!
  environment: Environment!
  appId: Int!
  appName: String!
}
type LogJob implements BotJob {
  type: BotJobType!
  bot: BotType!
  channel: String!
  level: AppLogLevel!
  message: String!
  metadata: Json
  timestamp: DateTime!
  status: AppState!
  environment: Environment!
  appId: Int!
  appName: String!
}
type StatusLogJob implements BotJob {
  type: BotJobType!
  bot: BotType!
  channel: String!
  level: AppLogLevel!
  newState: AppState!
  oldState: AppState!
  message: String!
  metadata: Json
  timestamp: DateTime!
  environment: Environment!
  appId: Int!
  appName: String!
}
type EventLog implements AppLog {
  id: Int!
  type: AppLogType!
  level: AppLogLevel!
  message: String!
  metadata: Json
  timestamp: DateTime!
  environment: Environment!
  appId: Int!
  app: App!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String!
  category: AppLogEventExtCategory!
}
type Log implements AppLog {
  id: Int!
  type: AppLogType!
  level: AppLogLevel!
  message: String!
  metadata: Json
  timestamp: DateTime!
  environment: Environment!
  appId: Int!
  app: App!
  createdAt: DateTime!
  updatedAt: DateTime!
}
type StatusLog implements AppLog {
  id: Int!
  type: AppLogType!
  level: AppLogLevel!
  message: String!
  metadata: Json
  timestamp: DateTime!
  environment: Environment!
  appId: Int!
  app: App!
  createdAt: DateTime!
  updatedAt: DateTime!
  state: AppState
}