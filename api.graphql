schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}
type Query {
  app(where: AppWhereUniqueInput!): App
  apps(where: AppWhereInput, orderBy: AppOrderByInput, first: Int!, last: Int!, before: AppWhereUniqueInput, after: AppWhereUniqueInput): [App!]!
  appSubscription(where: AppSubscriptionWhereUniqueInput!): AppSubscription
  appSubscriptions(where: AppSubscriptionWhereInput, orderBy: AppSubscriptionOrderByInput, first: Int!, last: Int!, before: AppSubscriptionWhereUniqueInput, after: AppSubscriptionWhereUniqueInput): [AppSubscription!]!
  botUser(where: BotUserWhereUniqueInput!): BotUser
  botUsers(where: BotUserWhereInput, orderBy: BotUserOrderByInput, first: Int!, last: Int!, before: BotUserWhereUniqueInput, after: BotUserWhereUniqueInput): [BotUser!]!
  clientSecret(where: ClientSecretWhereUniqueInput!): ClientSecret
  clientSecrets(where: ClientSecretWhereInput, orderBy: ClientSecretOrderByInput, first: Int!, last: Int!, before: ClientSecretWhereUniqueInput, after: ClientSecretWhereUniqueInput): [ClientSecret!]!
  subscribeToken(where: SubscribeTokenWhereUniqueInput!): SubscribeToken
  subscribeTokens(where: SubscribeTokenWhereInput, orderBy: SubscribeTokenOrderByInput, first: Int!, last: Int!, before: SubscribeTokenWhereUniqueInput, after: SubscribeTokenWhereUniqueInput): [SubscribeToken!]!
  whoAmI: UserAccount!
  userAccount(where: UserAccountWhereUniqueInput!): UserAccount
  userAccounts(where: UserAccountWhereInput, orderBy: UserAccountOrderByInput, first: Int!, last: Int!, before: UserAccountWhereUniqueInput, after: UserAccountWhereUniqueInput): [UserAccount!]!
}
input AppWhereUniqueInput {
  id: Int
  name_ownerId: NameOwnerIdCompoundUniqueInput
}
input NameOwnerIdCompoundUniqueInput {
  name: String!
  ownerId: Int!
}
type App {
  id: Int!
  name: String!
  ownerId: Int!
  owner: UserAccount!
  subscribeTokens(where: SubscribeTokenWhereInput, orderBy: SubscribeTokenOrderByInput): [SubscribeToken!]!
  appSubscriptions(where: AppSubscriptionWhereInput, orderBy: AppSubscriptionOrderByInput): [AppSubscription!]!
  clientSecrets(where: ClientSecretWhereInput, orderBy: ClientSecretOrderByInput): [ClientSecret!]!
  messages(where: AppMessageWhereInput): [AppMessage!]!
  subscribeTokenCount: Int!
  appSubscriptionCount: Int!
  metrics(period: AppMetricsPeriod! = month): AppMetrics!
  createdAt: DateTime!
  updatedAt: DateTime!
}
type UserAccount {
  id: Int!
  nickname: String
  name: String
  email: String
  role: Role!
  botUsers(where: BotUserWhereInput, orderBy: BotUserOrderByInput): [BotUser!]!
  apps(where: AppWhereInput, orderBy: AppOrderByInput): [App!]!
  appCount: Int!
  appSubscriptions(where: AppSubscriptionWhereInput, orderBy: AppSubscriptionOrderByInput): [AppSubscription!]!
  requiresUpdate: UpdateRequiredPayload!
  createdAt: DateTime!
  updatedAt: DateTime!
}
enum Role {
  ADMIN
  USER
}
input BotUserWhereInput {
  id: IntFilter
  name: NullableStringFilter
  botUser: StringFilter
  botId: IntFilter
  userAccountId: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  AND: [BotUserWhereInput!]
  OR: [BotUserWhereInput!]
  NOT: [BotUserWhereInput!]
  bot: BotWhereInput
  userAccount: UserAccountWhereInput
}
input IntFilter {
  equals: Int
  not: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
}
input NullableStringFilter {
  equals: String
  not: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
}
input StringFilter {
  equals: String
  not: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
}
input DateTimeFilter {
  equals: DateTime
  not: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
}
"""A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar."""
scalar DateTime
input BotWhereInput {
  id: IntFilter
  type: BotType
  botUsers: BotUserFilter
  appSubscriptions: AppSubscriptionFilter
  AND: [BotWhereInput!]
  OR: [BotWhereInput!]
  NOT: [BotWhereInput!]
}
enum BotType {
  SLACK
  TELEGRAM
}
input BotUserFilter {
  every: BotUserWhereInput
  some: BotUserWhereInput
  none: BotUserWhereInput
}
input AppSubscriptionFilter {
  every: AppSubscriptionWhereInput
  some: AppSubscriptionWhereInput
  none: AppSubscriptionWhereInput
}
input AppSubscriptionWhereInput {
  id: IntFilter
  name: StringFilter
  customName: NullableStringFilter
  description: StringFilter
  muted: BooleanFilter
  mutedUntil: NullableDateTimeFilter
  appId: IntFilter
  subscriberId: IntFilter
  botId: IntFilter
  channel: StringFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  AND: [AppSubscriptionWhereInput!]
  OR: [AppSubscriptionWhereInput!]
  NOT: [AppSubscriptionWhereInput!]
  app: AppWhereInput
  subscriber: UserAccountWhereInput
  bot: BotWhereInput
}
input BooleanFilter {
  equals: Boolean
  not: Boolean
}
input NullableDateTimeFilter {
  equals: DateTime
  not: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
}
input AppWhereInput {
  id: IntFilter
  name: StringFilter
  ownerId: IntFilter
  subscribeTokens: SubscribeTokenFilter
  appSubscriptions: AppSubscriptionFilter
  clientSecrets: ClientSecretFilter
  messages: AppMessageFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  AND: [AppWhereInput!]
  OR: [AppWhereInput!]
  NOT: [AppWhereInput!]
  owner: UserAccountWhereInput
}
input SubscribeTokenFilter {
  every: SubscribeTokenWhereInput
  some: SubscribeTokenWhereInput
  none: SubscribeTokenWhereInput
}
input SubscribeTokenWhereInput {
  id: IntFilter
  description: StringFilter
  token: StringFilter
  appId: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  AND: [SubscribeTokenWhereInput!]
  OR: [SubscribeTokenWhereInput!]
  NOT: [SubscribeTokenWhereInput!]
  app: AppWhereInput
}
input ClientSecretFilter {
  every: ClientSecretWhereInput
  some: ClientSecretWhereInput
  none: ClientSecretWhereInput
}
input ClientSecretWhereInput {
  id: IntFilter
  environment: Environment
  secret: StringFilter
  appId: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  AND: [ClientSecretWhereInput!]
  OR: [ClientSecretWhereInput!]
  NOT: [ClientSecretWhereInput!]
  app: AppWhereInput
}
enum Environment {
  DEVELOPMENT
  TEST
  PRODUCTION
}
input AppMessageFilter {
  every: AppMessageWhereInput
  some: AppMessageWhereInput
  none: AppMessageWhereInput
}
input AppMessageWhereInput {
  environment: Environment = PRODUCTION
}
input UserAccountWhereInput {
  id: IntFilter
  nickname: NullableStringFilter
  name: NullableStringFilter
  email: NullableStringFilter
  password: NullableStringFilter
  role: Role
  botUsers: BotUserFilter
  apps: AppFilter
  appSubscriptions: AppSubscriptionFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  AND: [UserAccountWhereInput!]
  OR: [UserAccountWhereInput!]
  NOT: [UserAccountWhereInput!]
}
input AppFilter {
  every: AppWhereInput
  some: AppWhereInput
  none: AppWhereInput
}
input BotUserOrderByInput {
  id: SortOrder
  name: SortOrder
  botUser: SortOrder
  botId: SortOrder
  userAccountId: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}
enum SortOrder {
  asc
  desc
}
type BotUser {
  id: Int!
  name: String
  botUser: String!
  botId: Int!
  bot: Bot!
  userAccountId: Int!
  userAccount: UserAccount!
  createdAt: DateTime!
  updatedAt: DateTime!
  requiresUpdate: UpdateRequiredPayload!
}
type Bot {
  id: Int!
  type: BotType!
  botUsers(first: Int!, last: Int!, before: BotUserWhereUniqueInput, after: BotUserWhereUniqueInput): [BotUser!]!
  appSubscriptions(first: Int!, last: Int!, before: AppSubscriptionWhereUniqueInput, after: AppSubscriptionWhereUniqueInput): [AppSubscription!]!
}
input BotUserWhereUniqueInput {
  id: Int
  botUser_botId: BotUserBotIdCompoundUniqueInput
}
input BotUserBotIdCompoundUniqueInput {
  botUser: String!
  botId: Int!
}
input AppSubscriptionWhereUniqueInput {
  id: Int
  name_appId: NameAppIdCompoundUniqueInput
  appId_botId_channel: AppIdBotIdChannelCompoundUniqueInput
}
input NameAppIdCompoundUniqueInput {
  name: String!
  appId: Int!
}
input AppIdBotIdChannelCompoundUniqueInput {
  appId: Int!
  botId: Int!
  channel: String!
}
type AppSubscription {
  id: Int!
  name: String!
  description: String!
  muted: Boolean!
  mutedUntil: DateTime
  appId: Int!
  app: App!
  subscriberId: Int!
  subscriber: UserAccount!
  botId: Int!
  bot: Bot!
  channel: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}
type UpdateRequiredPayload {
  required: Boolean!
  instant: Boolean!
  fields: [String!]!
}
input AppOrderByInput {
  id: SortOrder
  name: SortOrder
  ownerId: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}
input AppSubscriptionOrderByInput {
  id: SortOrder
  name: SortOrder
  customName: SortOrder
  description: SortOrder
  muted: SortOrder
  mutedUntil: SortOrder
  appId: SortOrder
  subscriberId: SortOrder
  botId: SortOrder
  channel: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}
input SubscribeTokenOrderByInput {
  id: SortOrder
  description: SortOrder
  token: SortOrder
  appId: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}
type SubscribeToken {
  id: Int!
  description: String!
  token: String!
  appId: Int!
  app: App!
  createdAt: DateTime!
  updatedAt: DateTime!
}
input ClientSecretOrderByInput {
  id: SortOrder
  environment: SortOrder
  secret: SortOrder
  appId: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}
type ClientSecret {
  id: Int!
  environment: Environment!
  secret: String!
  appId: Int!
  app: App!
  createdAt: DateTime!
  updatedAt: DateTime!
}
interface AppMessage {
  id: Int!
  environment: Environment!
  appId: Int!
  app: App!
}
enum AppMetricsPeriod {
  day
  week
  month
}
type AppMetrics {
  start: DateTime!
  end: DateTime!
  logs: Int!
  events: Int!
  statuses: Int!
  limit: Int!
}
input ClientSecretWhereUniqueInput {
  id: Int
  secret: String
  environment_appId: EnvironmentAppIdCompoundUniqueInput
}
input EnvironmentAppIdCompoundUniqueInput {
  environment: Environment!
  appId: Int!
}
input SubscribeTokenWhereUniqueInput {
  id: Int
  token: String
  description_appId: DescriptionAppIdCompoundUniqueInput
}
input DescriptionAppIdCompoundUniqueInput {
  description: String!
  appId: Int!
}
input UserAccountWhereUniqueInput {
  id: Int
  nickname: String
}
input UserAccountOrderByInput {
  id: SortOrder
  nickname: SortOrder
  name: SortOrder
  email: SortOrder
  password: SortOrder
  role: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}
type Mutation {
  createApp(data: AppCreateInput!): App!
  deleteApp(where: DeleteByIdInput!): App!
  createAppSubscription(data: AppSubscriptionCreateInput!): AppSubscription!
  muteAppSubscription(where: UpdateByIdInput!, data: AppSubscriptionMuteInput): AppSubscription!
  unmuteAppSubscription(where: UpdateByIdInput!): AppSubscription!
  deleteAppSubscription(where: DeleteByIdInput!): AppSubscription!
  signUp(data: SignUpInput!): UserAccountAndToken!
  signIn(data: SignInInput!): UserAccountAndToken!
  signInViaBot(data: SignInViaBotInput!): UserAccountAndToken!
  generateBotToken(data: GenerateBotTokenInput!): GenerateBotTokenPayload!
  updateBotUser(data: BotUserUpdateInput!, where: BotUserWhereUniqueInput!): BotUser
  sendAppEventMessage(data: AppEventMessageSendInput!): ClientResponse!
  sendAppLogMessage(data: AppLogMessageSendInput!): ClientResponse!
  sendAppStatusMessage(data: AppStatusMessageSendInput!): ClientResponse!
  regenerateClientSecret(where: ClientSecretRegenerateInput!): ClientSecret!
  createSubscribeToken(data: SubscribeTokenCreateInput!): SubscribeToken!
  deleteSubscribeToken(where: DeleteByIdInput!): SubscribeToken!
  updateUserAccount(data: UserAccountUpdateInput!, where: UserAccountWhereUniqueInput!): UserAccount
  deleteUserAccount(where: DeleteByIdInput!): UserAccount!
}
input AppCreateInput {
  name: String!
}
input DeleteByIdInput {
  id: Int!
}
input AppSubscriptionCreateInput {
  name: String!
  channel: String!
  subscribeToken: String!
  userToken: String!
}
input UpdateByIdInput {
  id: Int!
}
input AppSubscriptionMuteInput {
  muteUntil: DateTime
}
input SignUpInput {
  nickname: String!
  name: String!
  email: String!
  password: String!
}
type UserAccountAndToken {
  userAccount: UserAccount!
  token: String!
}
input SignInInput {
  nickname: String!
  password: String!
}
input SignInViaBotInput {
  botUser: String!
}
input GenerateBotTokenInput {
  bot: BotType!
}
type GenerateBotTokenPayload {
  token: String!
}
input BotUserUpdateInput {
  name: String
}
input AppEventMessageSendInput {
  title: String!
  category: AppEventCategory
  message: String!
  metadata: Json
  timestamp: DateTime!
}
enum AppEventCategory {
  NONE
  POST
  NEWS
  PAYMENT
  MAIL
  TRAIN
  TRAVELLING
  CAR
  INDUSTRY
  MUSIC
  VIDEO
  MOVIE
}
"""The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."""
scalar Json
type ClientResponse {
  success: Boolean!
}
input AppLogMessageSendInput {
  level: AppLogLevel!
  message: String!
  metadata: Json
  timestamp: DateTime!
}
enum AppLogLevel {
  INFO
  WARN
  ERROR
  FATAL
}
input AppStatusMessageSendInput {
  state: AppState!
  message: String!
  metadata: Json
  timestamp: DateTime!
}
enum AppState {
  UP
  SHUTDOWN
  UNKNOWN
  CRITICAL
  DOWN
}
input ClientSecretRegenerateInput {
  id: Int!
}
input SubscribeTokenCreateInput {
  description: String!
  appId: Int!
}
input UserAccountUpdateInput {
  nickname: String
  name: String
  email: String
  password: String
  role: Role
  apps: AppUpdateManyWithoutOwnerInput
  appSubscriptions: AppSubscriptionUpdateManyWithoutSubscriberInput
}
input AppUpdateManyWithoutOwnerInput {
  create: [AppCreateWithoutOwnerInput!]
  connect: [AppWhereUniqueInput!]
  set: [AppWhereUniqueInput!]
  disconnect: [AppWhereUniqueInput!]
  delete: [AppWhereUniqueInput!]
  update: [AppUpdateWithWhereUniqueWithoutOwnerInput!]
  updateMany: [AppUpdateManyWithWhereNestedInput!]
  deleteMany: [AppScalarWhereInput!]
  upsert: [AppUpsertWithWhereUniqueWithoutOwnerInput!]
}
input AppCreateWithoutOwnerInput {
  name: String!
  createdAt: DateTime
  updatedAt: DateTime
  subscribeTokens: SubscribeTokenCreateManyWithoutAppInput
  appSubscriptions: AppSubscriptionCreateManyWithoutAppInput
  clientSecrets: ClientSecretCreateManyWithoutAppInput
  messages: AppMessageCreateManyWithoutAppInput
}
input SubscribeTokenCreateManyWithoutAppInput {
  create: [SubscribeTokenCreateWithoutAppInput!]
  connect: [SubscribeTokenWhereUniqueInput!]
}
input SubscribeTokenCreateWithoutAppInput {
  description: String!
  token: String!
  createdAt: DateTime
  updatedAt: DateTime
}
input AppSubscriptionCreateManyWithoutAppInput {
  create: [AppSubscriptionCreateWithoutAppInput!]
  connect: [AppSubscriptionWhereUniqueInput!]
}
input AppSubscriptionCreateWithoutAppInput {
  name: String!
  customName: String
  description: String!
  muted: Boolean
  mutedUntil: DateTime
  channel: String!
  createdAt: DateTime
  updatedAt: DateTime
  subscriber: UserAccountCreateOneWithoutAppSubscriptionsInput!
  bot: BotCreateOneWithoutAppSubscriptionsInput!
}
input UserAccountCreateOneWithoutAppSubscriptionsInput {
  create: UserAccountCreateWithoutAppSubscriptionsInput
  connect: UserAccountWhereUniqueInput
}
input UserAccountCreateWithoutAppSubscriptionsInput {
  nickname: String
  name: String
  email: String
  password: String
  role: Role
  createdAt: DateTime
  updatedAt: DateTime
  botUsers: BotUserCreateManyWithoutUserAccountInput
  apps: AppCreateManyWithoutOwnerInput
}
input BotUserCreateManyWithoutUserAccountInput {
  create: [BotUserCreateWithoutUserAccountInput!]
  connect: [BotUserWhereUniqueInput!]
}
input BotUserCreateWithoutUserAccountInput {
  name: String
  botUser: String!
  createdAt: DateTime
  updatedAt: DateTime
  bot: BotCreateOneWithoutBotUsersInput!
}
input BotCreateOneWithoutBotUsersInput {
  create: BotCreateWithoutBotUsersInput
  connect: BotWhereUniqueInput
}
input BotCreateWithoutBotUsersInput {
  type: BotType!
  appSubscriptions: AppSubscriptionCreateManyWithoutBotInput
}
input AppSubscriptionCreateManyWithoutBotInput {
  create: [AppSubscriptionCreateWithoutBotInput!]
  connect: [AppSubscriptionWhereUniqueInput!]
}
input AppSubscriptionCreateWithoutBotInput {
  name: String!
  customName: String
  description: String!
  muted: Boolean
  mutedUntil: DateTime
  channel: String!
  createdAt: DateTime
  updatedAt: DateTime
  app: AppCreateOneWithoutAppSubscriptionsInput!
  subscriber: UserAccountCreateOneWithoutAppSubscriptionsInput!
}
input AppCreateOneWithoutAppSubscriptionsInput {
  create: AppCreateWithoutAppSubscriptionsInput
  connect: AppWhereUniqueInput
}
input AppCreateWithoutAppSubscriptionsInput {
  name: String!
  createdAt: DateTime
  updatedAt: DateTime
  owner: UserAccountCreateOneWithoutAppsInput!
  subscribeTokens: SubscribeTokenCreateManyWithoutAppInput
  clientSecrets: ClientSecretCreateManyWithoutAppInput
  messages: AppMessageCreateManyWithoutAppInput
}
input UserAccountCreateOneWithoutAppsInput {
  create: UserAccountCreateWithoutAppsInput
  connect: UserAccountWhereUniqueInput
}
input UserAccountCreateWithoutAppsInput {
  nickname: String
  name: String
  email: String
  password: String
  role: Role
  createdAt: DateTime
  updatedAt: DateTime
  botUsers: BotUserCreateManyWithoutUserAccountInput
  appSubscriptions: AppSubscriptionCreateManyWithoutSubscriberInput
}
input AppSubscriptionCreateManyWithoutSubscriberInput {
  create: [AppSubscriptionCreateWithoutSubscriberInput!]
  connect: [AppSubscriptionWhereUniqueInput!]
}
input AppSubscriptionCreateWithoutSubscriberInput {
  name: String!
  customName: String
  description: String!
  muted: Boolean
  mutedUntil: DateTime
  channel: String!
  createdAt: DateTime
  updatedAt: DateTime
  app: AppCreateOneWithoutAppSubscriptionsInput!
  bot: BotCreateOneWithoutAppSubscriptionsInput!
}
input BotCreateOneWithoutAppSubscriptionsInput {
  create: BotCreateWithoutAppSubscriptionsInput
  connect: BotWhereUniqueInput
}
input BotCreateWithoutAppSubscriptionsInput {
  type: BotType!
  botUsers: BotUserCreateManyWithoutBotInput
}
input BotUserCreateManyWithoutBotInput {
  create: [BotUserCreateWithoutBotInput!]
  connect: [BotUserWhereUniqueInput!]
}
input BotUserCreateWithoutBotInput {
  name: String
  botUser: String!
  createdAt: DateTime
  updatedAt: DateTime
  userAccount: UserAccountCreateOneWithoutBotUsersInput!
}
input UserAccountCreateOneWithoutBotUsersInput {
  create: UserAccountCreateWithoutBotUsersInput
  connect: UserAccountWhereUniqueInput
}
input UserAccountCreateWithoutBotUsersInput {
  nickname: String
  name: String
  email: String
  password: String
  role: Role
  createdAt: DateTime
  updatedAt: DateTime
  apps: AppCreateManyWithoutOwnerInput
  appSubscriptions: AppSubscriptionCreateManyWithoutSubscriberInput
}
input AppCreateManyWithoutOwnerInput {
  create: [AppCreateWithoutOwnerInput!]
  connect: [AppWhereUniqueInput!]
}
input BotWhereUniqueInput {
  id: Int
  type: BotType
}
input ClientSecretCreateManyWithoutAppInput {
  create: [ClientSecretCreateWithoutAppInput!]
  connect: [ClientSecretWhereUniqueInput!]
}
input ClientSecretCreateWithoutAppInput {
  environment: Environment!
  secret: String!
  createdAt: DateTime
  updatedAt: DateTime
}
input AppMessageCreateManyWithoutAppInput {
  create: [AppMessageCreateWithoutAppInput!]
  connect: [AppMessageWhereUniqueInput!]
}
input AppMessageCreateWithoutAppInput {
  type: AppMessageType!
  environment: Environment!
  timestamp: DateTime!
  createdAt: DateTime
  updatedAt: DateTime
  event: AppEventCreateOneWithoutAppMessageInput
  log: AppLogCreateOneWithoutAppMessageInput
  status: AppStatusCreateOneWithoutAppMessageInput
}
enum AppMessageType {
  EVENT
  LOG
  STATUS
}
input AppEventCreateOneWithoutAppMessageInput {
  create: AppEventCreateWithoutAppMessageInput
  connect: AppEventWhereUniqueInput
}
input AppEventCreateWithoutAppMessageInput {
  category: AppEventCategory
  title: String!
  message: String!
  metadata: Json
  createdAt: DateTime
  updatedAt: DateTime
}
input AppEventWhereUniqueInput {
  id: Int
}
input AppLogCreateOneWithoutAppMessageInput {
  create: AppLogCreateWithoutAppMessageInput
  connect: AppLogWhereUniqueInput
}
input AppLogCreateWithoutAppMessageInput {
  level: AppLogLevel!
  message: String!
  metadata: Json
  createdAt: DateTime
  updatedAt: DateTime
}
input AppLogWhereUniqueInput {
  id: Int
}
input AppStatusCreateOneWithoutAppMessageInput {
  create: AppStatusCreateWithoutAppMessageInput
  connect: AppStatusWhereUniqueInput
}
input AppStatusCreateWithoutAppMessageInput {
  state: AppState!
  message: String!
  metadata: Json
  createdAt: DateTime
  updatedAt: DateTime
}
input AppStatusWhereUniqueInput {
  id: Int
}
input AppMessageWhereUniqueInput {
  id: Int
  appId_environment_type_timestamp: AppIdEnvironmentTypeTimestampCompoundUniqueInput
}
input AppIdEnvironmentTypeTimestampCompoundUniqueInput {
  appId: Int!
  environment: Environment!
  type: AppMessageType!
  timestamp: DateTime!
}
input AppUpdateWithWhereUniqueWithoutOwnerInput {
  where: AppWhereUniqueInput!
  data: AppUpdateWithoutOwnerDataInput!
}
input AppUpdateWithoutOwnerDataInput {
  name: String
  createdAt: DateTime
  updatedAt: DateTime
  subscribeTokens: SubscribeTokenUpdateManyWithoutAppInput
  appSubscriptions: AppSubscriptionUpdateManyWithoutAppInput
  clientSecrets: ClientSecretUpdateManyWithoutAppInput
  messages: AppMessageUpdateManyWithoutAppInput
}
input SubscribeTokenUpdateManyWithoutAppInput {
  create: [SubscribeTokenCreateWithoutAppInput!]
  connect: [SubscribeTokenWhereUniqueInput!]
  set: [SubscribeTokenWhereUniqueInput!]
  disconnect: [SubscribeTokenWhereUniqueInput!]
  delete: [SubscribeTokenWhereUniqueInput!]
  update: [SubscribeTokenUpdateWithWhereUniqueWithoutAppInput!]
  updateMany: [SubscribeTokenUpdateManyWithWhereNestedInput!]
  deleteMany: [SubscribeTokenScalarWhereInput!]
  upsert: [SubscribeTokenUpsertWithWhereUniqueWithoutAppInput!]
}
input SubscribeTokenUpdateWithWhereUniqueWithoutAppInput {
  where: SubscribeTokenWhereUniqueInput!
  data: SubscribeTokenUpdateWithoutAppDataInput!
}
input SubscribeTokenUpdateWithoutAppDataInput {
  description: String
  token: String
  createdAt: DateTime
  updatedAt: DateTime
}
input SubscribeTokenUpdateManyWithWhereNestedInput {
  where: SubscribeTokenScalarWhereInput!
  data: SubscribeTokenUpdateManyDataInput!
}
input SubscribeTokenScalarWhereInput {
  id: IntFilter
  description: StringFilter
  token: StringFilter
  appId: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  AND: [SubscribeTokenScalarWhereInput!]
  OR: [SubscribeTokenScalarWhereInput!]
  NOT: [SubscribeTokenScalarWhereInput!]
}
input SubscribeTokenUpdateManyDataInput {
  description: String
  token: String
  createdAt: DateTime
  updatedAt: DateTime
}
input SubscribeTokenUpsertWithWhereUniqueWithoutAppInput {
  where: SubscribeTokenWhereUniqueInput!
  update: SubscribeTokenUpdateWithoutAppDataInput!
  create: SubscribeTokenCreateWithoutAppInput!
}
input AppSubscriptionUpdateManyWithoutAppInput {
  create: [AppSubscriptionCreateWithoutAppInput!]
  connect: [AppSubscriptionWhereUniqueInput!]
  set: [AppSubscriptionWhereUniqueInput!]
  disconnect: [AppSubscriptionWhereUniqueInput!]
  delete: [AppSubscriptionWhereUniqueInput!]
  update: [AppSubscriptionUpdateWithWhereUniqueWithoutAppInput!]
  updateMany: [AppSubscriptionUpdateManyWithWhereNestedInput!]
  deleteMany: [AppSubscriptionScalarWhereInput!]
  upsert: [AppSubscriptionUpsertWithWhereUniqueWithoutAppInput!]
}
input AppSubscriptionUpdateWithWhereUniqueWithoutAppInput {
  where: AppSubscriptionWhereUniqueInput!
  data: AppSubscriptionUpdateWithoutAppDataInput!
}
input AppSubscriptionUpdateWithoutAppDataInput {
  name: String
  customName: String
  description: String
  muted: Boolean
  mutedUntil: DateTime
  channel: String
  createdAt: DateTime
  updatedAt: DateTime
  subscriber: UserAccountUpdateOneRequiredWithoutAppSubscriptionsInput
  bot: BotUpdateOneRequiredWithoutAppSubscriptionsInput
}
input UserAccountUpdateOneRequiredWithoutAppSubscriptionsInput {
  create: UserAccountCreateWithoutAppSubscriptionsInput
  connect: UserAccountWhereUniqueInput
  update: UserAccountUpdateWithoutAppSubscriptionsDataInput
  upsert: UserAccountUpsertWithoutAppSubscriptionsInput
}
input UserAccountUpdateWithoutAppSubscriptionsDataInput {
  nickname: String
  name: String
  email: String
  password: String
  role: Role
  createdAt: DateTime
  updatedAt: DateTime
  botUsers: BotUserUpdateManyWithoutUserAccountInput
  apps: AppUpdateManyWithoutOwnerInput
}
input BotUserUpdateManyWithoutUserAccountInput {
  create: [BotUserCreateWithoutUserAccountInput!]
  connect: [BotUserWhereUniqueInput!]
  set: [BotUserWhereUniqueInput!]
  disconnect: [BotUserWhereUniqueInput!]
  delete: [BotUserWhereUniqueInput!]
  update: [BotUserUpdateWithWhereUniqueWithoutUserAccountInput!]
  updateMany: [BotUserUpdateManyWithWhereNestedInput!]
  deleteMany: [BotUserScalarWhereInput!]
  upsert: [BotUserUpsertWithWhereUniqueWithoutUserAccountInput!]
}
input BotUserUpdateWithWhereUniqueWithoutUserAccountInput {
  where: BotUserWhereUniqueInput!
  data: BotUserUpdateWithoutUserAccountDataInput!
}
input BotUserUpdateWithoutUserAccountDataInput {
  name: String
  botUser: String
  createdAt: DateTime
  updatedAt: DateTime
  bot: BotUpdateOneRequiredWithoutBotUsersInput
}
input BotUpdateOneRequiredWithoutBotUsersInput {
  create: BotCreateWithoutBotUsersInput
  connect: BotWhereUniqueInput
  update: BotUpdateWithoutBotUsersDataInput
  upsert: BotUpsertWithoutBotUsersInput
}
input BotUpdateWithoutBotUsersDataInput {
  type: BotType
  appSubscriptions: AppSubscriptionUpdateManyWithoutBotInput
}
input AppSubscriptionUpdateManyWithoutBotInput {
  create: [AppSubscriptionCreateWithoutBotInput!]
  connect: [AppSubscriptionWhereUniqueInput!]
  set: [AppSubscriptionWhereUniqueInput!]
  disconnect: [AppSubscriptionWhereUniqueInput!]
  delete: [AppSubscriptionWhereUniqueInput!]
  update: [AppSubscriptionUpdateWithWhereUniqueWithoutBotInput!]
  updateMany: [AppSubscriptionUpdateManyWithWhereNestedInput!]
  deleteMany: [AppSubscriptionScalarWhereInput!]
  upsert: [AppSubscriptionUpsertWithWhereUniqueWithoutBotInput!]
}
input AppSubscriptionUpdateWithWhereUniqueWithoutBotInput {
  where: AppSubscriptionWhereUniqueInput!
  data: AppSubscriptionUpdateWithoutBotDataInput!
}
input AppSubscriptionUpdateWithoutBotDataInput {
  name: String
  customName: String
  description: String
  muted: Boolean
  mutedUntil: DateTime
  channel: String
  createdAt: DateTime
  updatedAt: DateTime
  app: AppUpdateOneRequiredWithoutAppSubscriptionsInput
  subscriber: UserAccountUpdateOneRequiredWithoutAppSubscriptionsInput
}
input AppUpdateOneRequiredWithoutAppSubscriptionsInput {
  create: AppCreateWithoutAppSubscriptionsInput
  connect: AppWhereUniqueInput
  update: AppUpdateWithoutAppSubscriptionsDataInput
  upsert: AppUpsertWithoutAppSubscriptionsInput
}
input AppUpdateWithoutAppSubscriptionsDataInput {
  name: String
  createdAt: DateTime
  updatedAt: DateTime
  owner: UserAccountUpdateOneRequiredWithoutAppsInput
  subscribeTokens: SubscribeTokenUpdateManyWithoutAppInput
  clientSecrets: ClientSecretUpdateManyWithoutAppInput
  messages: AppMessageUpdateManyWithoutAppInput
}
input UserAccountUpdateOneRequiredWithoutAppsInput {
  create: UserAccountCreateWithoutAppsInput
  connect: UserAccountWhereUniqueInput
  update: UserAccountUpdateWithoutAppsDataInput
  upsert: UserAccountUpsertWithoutAppsInput
}
input UserAccountUpdateWithoutAppsDataInput {
  nickname: String
  name: String
  email: String
  password: String
  role: Role
  createdAt: DateTime
  updatedAt: DateTime
  botUsers: BotUserUpdateManyWithoutUserAccountInput
  appSubscriptions: AppSubscriptionUpdateManyWithoutSubscriberInput
}
input AppSubscriptionUpdateManyWithoutSubscriberInput {
  create: [AppSubscriptionCreateWithoutSubscriberInput!]
  connect: [AppSubscriptionWhereUniqueInput!]
  set: [AppSubscriptionWhereUniqueInput!]
  disconnect: [AppSubscriptionWhereUniqueInput!]
  delete: [AppSubscriptionWhereUniqueInput!]
  update: [AppSubscriptionUpdateWithWhereUniqueWithoutSubscriberInput!]
  updateMany: [AppSubscriptionUpdateManyWithWhereNestedInput!]
  deleteMany: [AppSubscriptionScalarWhereInput!]
  upsert: [AppSubscriptionUpsertWithWhereUniqueWithoutSubscriberInput!]
}
input AppSubscriptionUpdateWithWhereUniqueWithoutSubscriberInput {
  where: AppSubscriptionWhereUniqueInput!
  data: AppSubscriptionUpdateWithoutSubscriberDataInput!
}
input AppSubscriptionUpdateWithoutSubscriberDataInput {
  name: String
  customName: String
  description: String
  muted: Boolean
  mutedUntil: DateTime
  channel: String
  createdAt: DateTime
  updatedAt: DateTime
  app: AppUpdateOneRequiredWithoutAppSubscriptionsInput
  bot: BotUpdateOneRequiredWithoutAppSubscriptionsInput
}
input BotUpdateOneRequiredWithoutAppSubscriptionsInput {
  create: BotCreateWithoutAppSubscriptionsInput
  connect: BotWhereUniqueInput
  update: BotUpdateWithoutAppSubscriptionsDataInput
  upsert: BotUpsertWithoutAppSubscriptionsInput
}
input BotUpdateWithoutAppSubscriptionsDataInput {
  type: BotType
  botUsers: BotUserUpdateManyWithoutBotInput
}
input BotUserUpdateManyWithoutBotInput {
  create: [BotUserCreateWithoutBotInput!]
  connect: [BotUserWhereUniqueInput!]
  set: [BotUserWhereUniqueInput!]
  disconnect: [BotUserWhereUniqueInput!]
  delete: [BotUserWhereUniqueInput!]
  update: [BotUserUpdateWithWhereUniqueWithoutBotInput!]
  updateMany: [BotUserUpdateManyWithWhereNestedInput!]
  deleteMany: [BotUserScalarWhereInput!]
  upsert: [BotUserUpsertWithWhereUniqueWithoutBotInput!]
}
input BotUserUpdateWithWhereUniqueWithoutBotInput {
  where: BotUserWhereUniqueInput!
  data: BotUserUpdateWithoutBotDataInput!
}
input BotUserUpdateWithoutBotDataInput {
  name: String
  botUser: String
  createdAt: DateTime
  updatedAt: DateTime
  userAccount: UserAccountUpdateOneRequiredWithoutBotUsersInput
}
input UserAccountUpdateOneRequiredWithoutBotUsersInput {
  create: UserAccountCreateWithoutBotUsersInput
  connect: UserAccountWhereUniqueInput
  update: UserAccountUpdateWithoutBotUsersDataInput
  upsert: UserAccountUpsertWithoutBotUsersInput
}
input UserAccountUpdateWithoutBotUsersDataInput {
  nickname: String
  name: String
  email: String
  password: String
  role: Role
  createdAt: DateTime
  updatedAt: DateTime
  apps: AppUpdateManyWithoutOwnerInput
  appSubscriptions: AppSubscriptionUpdateManyWithoutSubscriberInput
}
input UserAccountUpsertWithoutBotUsersInput {
  update: UserAccountUpdateWithoutBotUsersDataInput!
  create: UserAccountCreateWithoutBotUsersInput!
}
input BotUserUpdateManyWithWhereNestedInput {
  where: BotUserScalarWhereInput!
  data: BotUserUpdateManyDataInput!
}
input BotUserScalarWhereInput {
  id: IntFilter
  name: NullableStringFilter
  botUser: StringFilter
  botId: IntFilter
  userAccountId: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  AND: [BotUserScalarWhereInput!]
  OR: [BotUserScalarWhereInput!]
  NOT: [BotUserScalarWhereInput!]
}
input BotUserUpdateManyDataInput {
  name: String
  botUser: String
  createdAt: DateTime
  updatedAt: DateTime
}
input BotUserUpsertWithWhereUniqueWithoutBotInput {
  where: BotUserWhereUniqueInput!
  update: BotUserUpdateWithoutBotDataInput!
  create: BotUserCreateWithoutBotInput!
}
input BotUpsertWithoutAppSubscriptionsInput {
  update: BotUpdateWithoutAppSubscriptionsDataInput!
  create: BotCreateWithoutAppSubscriptionsInput!
}
input AppSubscriptionUpdateManyWithWhereNestedInput {
  where: AppSubscriptionScalarWhereInput!
  data: AppSubscriptionUpdateManyDataInput!
}
input AppSubscriptionScalarWhereInput {
  id: IntFilter
  name: StringFilter
  customName: NullableStringFilter
  description: StringFilter
  muted: BooleanFilter
  mutedUntil: NullableDateTimeFilter
  appId: IntFilter
  subscriberId: IntFilter
  botId: IntFilter
  channel: StringFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  AND: [AppSubscriptionScalarWhereInput!]
  OR: [AppSubscriptionScalarWhereInput!]
  NOT: [AppSubscriptionScalarWhereInput!]
}
input AppSubscriptionUpdateManyDataInput {
  name: String
  customName: String
  description: String
  muted: Boolean
  mutedUntil: DateTime
  channel: String
  createdAt: DateTime
  updatedAt: DateTime
}
input AppSubscriptionUpsertWithWhereUniqueWithoutSubscriberInput {
  where: AppSubscriptionWhereUniqueInput!
  update: AppSubscriptionUpdateWithoutSubscriberDataInput!
  create: AppSubscriptionCreateWithoutSubscriberInput!
}
input UserAccountUpsertWithoutAppsInput {
  update: UserAccountUpdateWithoutAppsDataInput!
  create: UserAccountCreateWithoutAppsInput!
}
input ClientSecretUpdateManyWithoutAppInput {
  create: [ClientSecretCreateWithoutAppInput!]
  connect: [ClientSecretWhereUniqueInput!]
  set: [ClientSecretWhereUniqueInput!]
  disconnect: [ClientSecretWhereUniqueInput!]
  delete: [ClientSecretWhereUniqueInput!]
  update: [ClientSecretUpdateWithWhereUniqueWithoutAppInput!]
  updateMany: [ClientSecretUpdateManyWithWhereNestedInput!]
  deleteMany: [ClientSecretScalarWhereInput!]
  upsert: [ClientSecretUpsertWithWhereUniqueWithoutAppInput!]
}
input ClientSecretUpdateWithWhereUniqueWithoutAppInput {
  where: ClientSecretWhereUniqueInput!
  data: ClientSecretUpdateWithoutAppDataInput!
}
input ClientSecretUpdateWithoutAppDataInput {
  environment: Environment
  secret: String
  createdAt: DateTime
  updatedAt: DateTime
}
input ClientSecretUpdateManyWithWhereNestedInput {
  where: ClientSecretScalarWhereInput!
  data: ClientSecretUpdateManyDataInput!
}
input ClientSecretScalarWhereInput {
  id: IntFilter
  environment: Environment
  secret: StringFilter
  appId: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  AND: [ClientSecretScalarWhereInput!]
  OR: [ClientSecretScalarWhereInput!]
  NOT: [ClientSecretScalarWhereInput!]
}
input ClientSecretUpdateManyDataInput {
  environment: Environment
  secret: String
  createdAt: DateTime
  updatedAt: DateTime
}
input ClientSecretUpsertWithWhereUniqueWithoutAppInput {
  where: ClientSecretWhereUniqueInput!
  update: ClientSecretUpdateWithoutAppDataInput!
  create: ClientSecretCreateWithoutAppInput!
}
input AppMessageUpdateManyWithoutAppInput {
  create: [AppMessageCreateWithoutAppInput!]
  connect: [AppMessageWhereUniqueInput!]
  set: [AppMessageWhereUniqueInput!]
  disconnect: [AppMessageWhereUniqueInput!]
  delete: [AppMessageWhereUniqueInput!]
  update: [AppMessageUpdateWithWhereUniqueWithoutAppInput!]
  updateMany: [AppMessageUpdateManyWithWhereNestedInput!]
  deleteMany: [AppMessageScalarWhereInput!]
  upsert: [AppMessageUpsertWithWhereUniqueWithoutAppInput!]
}
input AppMessageUpdateWithWhereUniqueWithoutAppInput {
  where: AppMessageWhereUniqueInput!
  data: AppMessageUpdateWithoutAppDataInput!
}
input AppMessageUpdateWithoutAppDataInput {
  type: AppMessageType
  environment: Environment
  timestamp: DateTime
  createdAt: DateTime
  updatedAt: DateTime
  event: AppEventUpdateOneWithoutAppMessageInput
  log: AppLogUpdateOneWithoutAppMessageInput
  status: AppStatusUpdateOneWithoutAppMessageInput
}
input AppEventUpdateOneWithoutAppMessageInput {
  create: AppEventCreateWithoutAppMessageInput
  connect: AppEventWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: AppEventUpdateWithoutAppMessageDataInput
  upsert: AppEventUpsertWithoutAppMessageInput
}
input AppEventUpdateWithoutAppMessageDataInput {
  category: AppEventCategory
  title: String
  message: String
  metadata: Json
  createdAt: DateTime
  updatedAt: DateTime
}
input AppEventUpsertWithoutAppMessageInput {
  update: AppEventUpdateWithoutAppMessageDataInput!
  create: AppEventCreateWithoutAppMessageInput!
}
input AppLogUpdateOneWithoutAppMessageInput {
  create: AppLogCreateWithoutAppMessageInput
  connect: AppLogWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: AppLogUpdateWithoutAppMessageDataInput
  upsert: AppLogUpsertWithoutAppMessageInput
}
input AppLogUpdateWithoutAppMessageDataInput {
  level: AppLogLevel
  message: String
  metadata: Json
  createdAt: DateTime
  updatedAt: DateTime
}
input AppLogUpsertWithoutAppMessageInput {
  update: AppLogUpdateWithoutAppMessageDataInput!
  create: AppLogCreateWithoutAppMessageInput!
}
input AppStatusUpdateOneWithoutAppMessageInput {
  create: AppStatusCreateWithoutAppMessageInput
  connect: AppStatusWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: AppStatusUpdateWithoutAppMessageDataInput
  upsert: AppStatusUpsertWithoutAppMessageInput
}
input AppStatusUpdateWithoutAppMessageDataInput {
  state: AppState
  message: String
  metadata: Json
  createdAt: DateTime
  updatedAt: DateTime
}
input AppStatusUpsertWithoutAppMessageInput {
  update: AppStatusUpdateWithoutAppMessageDataInput!
  create: AppStatusCreateWithoutAppMessageInput!
}
input AppMessageUpdateManyWithWhereNestedInput {
  where: AppMessageScalarWhereInput!
  data: AppMessageUpdateManyDataInput!
}
input AppMessageScalarWhereInput {
  id: IntFilter
  type: AppMessageType
  appId: IntFilter
  environment: Environment
  timestamp: DateTimeFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  AND: [AppMessageScalarWhereInput!]
  OR: [AppMessageScalarWhereInput!]
  NOT: [AppMessageScalarWhereInput!]
}
input AppMessageUpdateManyDataInput {
  type: AppMessageType
  environment: Environment
  timestamp: DateTime
  createdAt: DateTime
  updatedAt: DateTime
}
input AppMessageUpsertWithWhereUniqueWithoutAppInput {
  where: AppMessageWhereUniqueInput!
  update: AppMessageUpdateWithoutAppDataInput!
  create: AppMessageCreateWithoutAppInput!
}
input AppUpsertWithoutAppSubscriptionsInput {
  update: AppUpdateWithoutAppSubscriptionsDataInput!
  create: AppCreateWithoutAppSubscriptionsInput!
}
input AppSubscriptionUpsertWithWhereUniqueWithoutBotInput {
  where: AppSubscriptionWhereUniqueInput!
  update: AppSubscriptionUpdateWithoutBotDataInput!
  create: AppSubscriptionCreateWithoutBotInput!
}
input BotUpsertWithoutBotUsersInput {
  update: BotUpdateWithoutBotUsersDataInput!
  create: BotCreateWithoutBotUsersInput!
}
input BotUserUpsertWithWhereUniqueWithoutUserAccountInput {
  where: BotUserWhereUniqueInput!
  update: BotUserUpdateWithoutUserAccountDataInput!
  create: BotUserCreateWithoutUserAccountInput!
}
input UserAccountUpsertWithoutAppSubscriptionsInput {
  update: UserAccountUpdateWithoutAppSubscriptionsDataInput!
  create: UserAccountCreateWithoutAppSubscriptionsInput!
}
input AppSubscriptionUpsertWithWhereUniqueWithoutAppInput {
  where: AppSubscriptionWhereUniqueInput!
  update: AppSubscriptionUpdateWithoutAppDataInput!
  create: AppSubscriptionCreateWithoutAppInput!
}
input AppUpdateManyWithWhereNestedInput {
  where: AppScalarWhereInput!
  data: AppUpdateManyDataInput!
}
input AppScalarWhereInput {
  id: IntFilter
  name: StringFilter
  ownerId: IntFilter
  subscribeTokens: SubscribeTokenFilter
  appSubscriptions: AppSubscriptionFilter
  clientSecrets: ClientSecretFilter
  messages: AppMessageFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  AND: [AppScalarWhereInput!]
  OR: [AppScalarWhereInput!]
  NOT: [AppScalarWhereInput!]
}
input AppUpdateManyDataInput {
  name: String
  createdAt: DateTime
  updatedAt: DateTime
}
input AppUpsertWithWhereUniqueWithoutOwnerInput {
  where: AppWhereUniqueInput!
  update: AppUpdateWithoutOwnerDataInput!
  create: AppCreateWithoutOwnerInput!
}
type Subscription {
  appMessage(app: Int!): AppMessage!
}
enum BotJobType {
  EVENT
  LOG
  STATUS
}
interface BotJob {
  type: BotJobType!
  bot: BotType!
  channel: String!
}
type AppEventMessageJob implements BotJob {
  type: BotJobType!
  bot: BotType!
  channel: String!
  appId: Int!
  appName: String!
  environment: Environment!
  title: String!
  category: AppEventCategory
  message: String!
  metadata: Json
  status: AppState!
  timestamp: DateTime!
}
type AppLogMessageJob implements BotJob {
  type: BotJobType!
  bot: BotType!
  channel: String!
  appId: Int!
  appName: String!
  environment: Environment!
  level: AppLogLevel!
  message: String!
  metadata: Json
  status: AppState!
  timestamp: DateTime!
}
type AppStatusMessageJob implements BotJob {
  type: BotJobType!
  bot: BotType!
  channel: String!
  appId: Int!
  appName: String!
  environment: Environment!
  newState: AppState!
  oldState: AppState!
  message: String!
  metadata: Json
  timestamp: DateTime!
}
type AppEvent implements AppMessage {
  id: Int!
  environment: Environment!
  appId: Int!
  app: App!
  title: String!
  category: AppEventCategory!
  message: String!
  metadata: Json
  createdAt: DateTime!
  updatedAt: DateTime!
}
type AppLog implements AppMessage {
  id: Int!
  environment: Environment!
  appId: Int!
  app: App!
  level: AppLogLevel!
  message: String!
  metadata: Json
  createdAt: DateTime!
  updatedAt: DateTime!
}
type AppStatus implements AppMessage {
  id: Int!
  environment: Environment!
  appId: Int!
  app: App!
  state: AppState!
  message: String!
  metadata: Json
  createdAt: DateTime!
  updatedAt: DateTime!
}